# -*- coding: utf-8 -*-
"""BSProjectVisualization

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n1xeVQ2JRsiuNJ1w1g-Zs0Ww65fP7qSV

# OV7675 Image Viewer
Takes the hexadecimal output of the Camera Test from the Serial Monitor and converts and displays it as an image.
"""

# Import the needed libraries
from matplotlib import pyplot as plt
import numpy as np
import struct
import string
import time

# Initialize a counter variable
a = 1
lon_index = 0

#Count the number of potholes
count = 0
with open("POTHOLE.TXT", "r") as file:
    for line in file:
        count += line.count("Pothole")

# Loop through the file
for j in range(count):

  # Open the text file for reading
  with open("POTHOLE.TXT", "r") as file:
    contents = file.read()

  nextPothole = "Pothole " + str(a)

  # Find the index of the start of the next pothole section in the text file
  index = contents.find("Pothole", lon_index)

  # Find the index of the next newline character after the start of the section
  newline_index = contents.find("\n", index)

  # Find the index of the next newline character after the previous one
  next_newline_index = contents.find("\n", newline_index + 1)

  # Find the index of the next newline character after the previous one
  next_index_enter = contents.find("\n", next_newline_index + 1)

  # Find the index of the "LAT=" substring in the current section
  lat_index = contents.find("LAT= ", next_index_enter)

  # Find the index of the "LNG=" substring in the current section
  lon_index = contents.find("LNG= ", lat_index)

  # Extract the latitude and longititude values from the current section
  LAT = contents[lat_index: lat_index+10]
  LNG = contents[lon_index: lon_index+10]

  # Extract the hexadecimal values for the image data as a string
  hex_string = contents[newline_index + 2: next_index_enter - 1]

  # Split the hexadecimal string into a list of values
  hex_list = hex_string.split(",")

  # Convert the hexadecimal values from strings to integers
  hex_int = [0]*len(hex_list)
  new_int = [0]*len(hex_list)
  for b in range(len(hex_list)):
    hex_int[b] = int(hex_list[b], 16)
    new_int[b] = hex_int[b]

  # Convert the integer values to raw bytes
  raw_bytes = np.array(new_int, dtype="i2")

  # Create an array to store the RGB values for each pixel
  image = np.zeros((len(raw_bytes),3), dtype=int)

  # Loop through all of the pixels and form the image
  for i in range(len(raw_bytes)):
      # Read a 16-bit pixel from the raw bytes
      pixel = struct.unpack('>h', raw_bytes[i])[0]

      # Convert the RGB565 format to RGB 24-bit
      r = ((pixel >> 11) & 0x1f) << 3;
      g = ((pixel >> 5) & 0x3f) << 2;
      b = ((pixel >> 0) & 0x1f) << 3;
      image[i] = [r,g,b]

  # Reshape the image array to match the QCIF resolution (52x52 pixels)
  image = np.reshape(image,(52, 52,3))

  # Show the image and add the latitude and longitude values as text in the top right corner
  plt.imshow(image)
  # Add LAT and LNG values to image
  plt.text(0.90, 0.10, f'{LAT}, {LNG}', horizontalalignment='right',
         verticalalignment='bottom', transform=plt.gca().transAxes, fontsize=12, color='WHITE', weight='bold')

  # Construct the filename for the plot based on the value of a
  nameOfFile = 'Pothole' + str(a) + '.jpeg'

  # Set the plot title to "Pothole" followed by the value of a
  plt.title('Pothole ' + str(a))

  # Save the plot to the file with the constructed filename
  plt.savefig(nameOfFile)

  # Display the plot on the screen
  plt.show()
  a = a+1